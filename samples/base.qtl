// ========================================================================
//  QUANTEL SYSTEM INTEGRITY TEST
//  Validation: Fixed for strict (DTYPE + SHAPE) requirement
// ========================================================================

import math;

// [TEST 2] Record Definitions
// Rules: RECORD ID LBRACE decl_list RBRACE
record NeuralConfig {
    float32 scalar learning_rate;
    int32 scalar max_epochs;
    bool scalar is_active;
}

// [TEST 3] Function Declaration
// Rules: FUNC ID ... ARROW dtype shape_type block
func relu_activation(float32 scalar val) -> float32 scalar {
    if (val > 0.0 && val < 100.0) {
        return val;
    } else {
        return 0.0;
    }
}

// [TEST 4] Global Variables
// Rules: dtype shape_type ID ASSIGN expr SEMICOLON
int32 scalar epoch_counter = 0;
float32 scalar bias_correction = 0.01;

// [TEST 5] Linear Algebra
// Rules: matrix < num, num > and vector < num >
float32 matrix<3,3> Weights = [
    [0.5, -0.2, 0.1],
    [0.9,  0.0, -0.3],
    [0.2,  0.1,  0.4]
];

float32 vector<3> input_vec = [1.0, 2.0, 0.5];
float32 vector<3> bias = [0.1, 0.1, -0.5];

// [TEST 6] Mathematical Operations
// Using AUTO for inference (Parser Rule 3)
auto z = Weights @ input_vec + bias;
probe(z);

// [TEST 7] Slicing
auto subset = z[0..2];

// [TEST 8] Iteration
float32 scalar total_activation = 0.0;

for i in 0..3 {
    // Note: 'val' and 'activated' use auto for simplicity
    auto val = z[i];
    auto activated = relu_activation(val);
    total_activation += activated;
}
probe(total_activation);

// [TEST 9] Control Flow
int32 scalar safe_mode = 1;
while (safe_mode != 0) {
    if (total_activation > 100.0) {
        break; 
    }
    safe_mode = 0; 
}

// [TEST 10] Pointers
// Rule: dtype shape_type TIMES ID ASSIGN AMPERSAND ID SEMICOLON
float32 scalar *ptr = &total_activation;
probe(ptr);

// [TEST 11] Logic
if (safe_mode == 0) {
    probe("System Check: PASSED");
} else {
    probe("System Check: FAILED");
}